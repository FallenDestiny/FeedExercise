{"version":3,"sources":["value.js"],"names":["Value","value","prop","varsArr","options","outValue","stack","isOperation","undefined","calcString","proxyValue","isFinal","applyScale","actions","tryCalcOperation","tryCalcPercent","tryCalcVar","tryCalcRem","filter","Boolean","tryActions","str","i","length","val","call","opInfo","operation","operands","operand","operandValue","calcOperandValue","exec","tryCalcFloat","vars","isVar","calc","indexOf","Error","concat","join","percent","isPercent","rem","isRem","remValue","get","parseFloat","isNaN","scaleFactor","scale","isScalable"],"mappings":";;;;;;;;;;;AAIA;;AACA;;AACA;;AACA;;AACA;;IAEqBA,K;AAWnB,iBAAYC,KAAZ,EAAmBC,IAAnB,EAAqD;AAAA,QAA5BC,OAA4B,uEAAlB,EAAkB;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAAA;AACnD,SAAKH,KAAL,GAAaA,KAAb;AACA,SAAKI,QAAL,GAAgB,IAAhB;AACA,SAAKH,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKG,KAAL,GAAaF,OAAO,CAACE,KAAR,IAAiB,EAA9B;AACA,SAAKC,WAAL,GAAmBH,OAAO,CAACG,WAAR,KAAwBC,SAAxB,GAAoCJ,OAAO,CAACG,WAA5C,GAA0D,KAA7E;AACD;;;;2BAMM;AACL,UAAI,OAAO,KAAKN,KAAZ,KAAsB,UAA1B,EAAsC;AACpC,aAAKA,KAAL,GAAa,KAAKA,KAAL,EAAb;AACD;;AAED,UAAI,OAAO,KAAKA,KAAZ,KAAsB,QAA1B,EAAoC;AAClC,aAAKQ,UAAL;AACD,OAFD,MAEO;AACL,aAAKC,UAAL;AACD;;AAED,UAAI,KAAKC,OAAL,EAAJ,EAAoB;AAClB,aAAKC,UAAL;AACD;;AAED,aAAO,KAAKP,QAAZ;AACD;;;iCAOY;AACX,UAAIQ,OAAO,GAAG,CACZ,KAAKC,gBADO,EAEZ,KAAKP,WAAL,GAAmB,KAAKQ,cAAxB,GAAyC,IAF7B,EAGZ,KAAKC,UAHO,EAIZ,KAAKC,UAJO,EAKZC,MALY,CAKLC,OALK,CAAd;AAMA,UAAIlB,KAAK,GAAG,KAAKmB,UAAL,CAAgBP,OAAhB,EAAyB,KAAKZ,KAA9B,CAAZ;;AACA,UAAIA,KAAK,KAAK,IAAd,EAAoB;AAClB,aAAKI,QAAL,GAAgBJ,KAAhB;AACD,OAFD,MAEO;AACL,aAAKS,UAAL;AACD;AACF;;;+BAOUG,O,EAASQ,G,EAAK;AAEvB,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,OAAO,CAACU,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvC,YAAIE,GAAG,GAAGX,OAAO,CAACS,CAAD,CAAP,CAAWG,IAAX,CAAgB,IAAhB,EAAsBJ,GAAtB,CAAV;;AACA,YAAIG,GAAG,KAAK,IAAZ,EAAkB;AAChB,iBAAOA,GAAP;AACD;AACF;;AACD,aAAO,IAAP;AACD;;;qCAEgBH,G,EAAK;AACpB,UAAIK,MAAM,GAAGC,mBAAUpB,WAAV,CAAsBc,GAAtB,CAAb;;AACA,UAAI,CAACK,MAAL,EAAa;AACX,eAAO,IAAP;AACD;;AACD,WAAKnB,WAAL,GAAmB,IAAnB;AAEA,UAAMqB,QAAQ,GAAG,CAAC,IAAD,EAAO,IAAP,CAAjB;;AACA,WAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,QAAQ,CAACL,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,YAAMO,OAAO,GAAGD,QAAQ,CAACN,CAAD,CAAxB;AACA,YAAMQ,YAAY,GAAG,KAAKC,gBAAL,CAAsBL,MAAM,CAACG,OAAD,CAA5B,CAArB;;AACA,YAAIC,YAAY,KAAK,IAArB,EAA2B;AACzBJ,UAAAA,MAAM,CAACG,OAAD,CAAN,GAAkBC,YAAlB;AACD,SAFD,MAEO;AAEL,iBAAO,IAAP;AACD;AACF;;AACD,aAAOH,mBAAUK,IAAV,CAAeN,MAAf,CAAP;AACD;;;qCAEgBL,G,EAAK;AACpB,UAAIR,OAAO,GAAG,CACZ,KAAKG,UADO,EAEZ,KAAKD,cAFO,EAGZ,KAAKE,UAHO,EAIZ,KAAKgB,YAJO,CAAd;AAMA,aAAO,KAAKb,UAAL,CAAgBP,OAAhB,EAAyBQ,GAAzB,CAAP;AACD;;;+BAEUA,G,EAAK;AACd,UAAIa,cAAKC,KAAL,CAAWd,GAAX,CAAJ,EAAqB;AACnB,YAAIG,GAAG,GAAGU,cAAKE,IAAL,CAAUf,GAAV,EAAe,KAAKlB,OAApB,CAAV;;AACA,YAAI,KAAKG,KAAL,CAAW+B,OAAX,CAAmBhB,GAAnB,KAA2B,CAA/B,EAAkC;AAChC,gBAAM,IAAIiB,KAAJ,CAAU,uBAAuB,KAAKhC,KAAL,CAAWiC,MAAX,CAAkB,CAAClB,GAAD,CAAlB,EAAyBmB,IAAzB,CAA8B,MAA9B,CAAjC,CAAN;AACD;;AACD,YAAMpC,OAAO,GAAG;AACdE,UAAAA,KAAK,EAAE,KAAKA,KAAL,CAAWiC,MAAX,CAAkB,CAAClB,GAAD,CAAlB,CADO;AAEdd,UAAAA,WAAW,EAAE,KAAKA;AAFJ,SAAhB;AAKA,eAAO,IAAIP,KAAJ,CAAUwB,GAAV,EAAeH,GAAf,EAAoB,KAAKlB,OAAzB,EAAkCC,OAAlC,EAA2CgC,IAA3C,EAAP;AACD,OAXD,MAWO;AACL,eAAO,IAAP;AACD;AACF;;;mCAKcf,G,EAAK;AAClB,UAAIoB,iBAAQC,SAAR,CAAkBrB,GAAlB,CAAJ,EAA4B;AAC1B,eAAOoB,iBAAQL,IAAR,CAAaf,GAAb,EAAkB,KAAKnB,IAAvB,CAAP;AACD;;AACD,aAAO,IAAP;AACD;;;+BAKUmB,G,EAAK;AACd,UAAIsB,aAAIC,KAAJ,CAAUvB,GAAV,CAAJ,EAAoB;AAClB,YAAIwB,QAAQ,GAAGX,cAAKY,GAAL,CAAS,MAAT,EAAiB,KAAK3C,OAAtB,CAAf;;AACA,eAAOwC,aAAIP,IAAJ,CAASf,GAAT,EAAcwB,QAAd,CAAP;AACD,OAHD,MAGO;AACL,eAAO,IAAP;AACD;AACF;;;iCAKYxB,G,EAAK;AAChB,UAAIG,GAAG,GAAGuB,UAAU,CAAC1B,GAAD,CAApB;AACA,aAAO,CAAC2B,KAAK,CAACxB,GAAD,CAAN,GAAcA,GAAd,GAAoB,IAA3B;AACD;;;8BAKS;AACR,aAAO,CAAC,KAAKlB,KAAL,CAAWiB,MAAnB;AACD;;;iCAKY;AACX,WAAKlB,QAAL,GAAgB,KAAKJ,KAArB;AACD;;;iCAEY;AAGX,UAAIiC,cAAKC,KAAL,CAAW,KAAKjC,IAAhB,CAAJ,EAA2B;AACzB;AACD;;AACD,UAAI+C,WAAW,GAAGf,cAAKY,GAAL,CAAS,QAAT,EAAmB,KAAK3C,OAAxB,KAAoC,CAAtD;;AACA,UAAI8C,WAAW,KAAK,CAApB,EAAuB;AACrB;AACD;;AACD,UAAIC,eAAMC,UAAN,CAAiB,KAAK9C,QAAtB,EAAgC,KAAKH,IAArC,CAAJ,EAAgD;AAC9C,aAAKG,QAAL,GAAgB6C,eAAMd,IAAN,CAAW,KAAK/B,QAAhB,EAA0B4C,WAA1B,CAAhB;AACD;AACF","sourcesContent":["/**\n * Calculates particular value\n */\n\nimport rem from './replacers/rem';\nimport vars from './replacers/vars';\nimport percent from './replacers/percent';\nimport operation from './replacers/operation';\nimport scale from './replacers/scale';\n\nexport default class Value {\n  /**\n   * Constructor\n   *\n   * @param {*} value\n   * @param {String} prop property for which valye is calculated\n   * @param {Array} varsArr array of objects with vars\n   * @param {Object} [options]\n   * @param {Array} [options.stack] stack of calls when resolving variable\n   * @param {Boolean} [options.isOperation] is value calculated inside operation\n   */\n  constructor(value, prop, varsArr = [], options = {}) {\n    this.value = value;\n    this.outValue = null;\n    this.prop = prop;\n    this.varsArr = varsArr;\n    this.stack = options.stack || [];\n    this.isOperation = options.isOperation !== undefined ? options.isOperation : false;\n  }\n\n  /**\n   * Calculates value:\n   * execute function, resolve var refs, convert string of (rem, percent) to pixels\n   */\n  calc() {\n    if (typeof this.value === 'function') {\n      this.value = this.value();\n    }\n\n    if (typeof this.value === 'string') {\n      this.calcString();\n    } else {\n      this.proxyValue();\n    }\n\n    if (this.isFinal()) {\n      this.applyScale();\n    }\n\n    return this.outValue;\n  }\n\n  /**\n   * Calculates string\n   * Here we do not calc direct percent values as they supported natively since RN 43 (#32).\n   * But keep calculating percent for operands when value defined as operation.\n   */\n  calcString() {\n    let actions = [\n      this.tryCalcOperation,\n      this.isOperation ? this.tryCalcPercent : null,\n      this.tryCalcVar,\n      this.tryCalcRem,\n    ].filter(Boolean);\n    let value = this.tryActions(actions, this.value);\n    if (value !== null) {\n      this.outValue = value;\n    } else {\n      this.proxyValue();\n    }\n  }\n\n  /**\n   * Applies array of calculations to value. Stops on the first calculation that returns not null.\n   * @param {Array} actions\n   * @param {String} str\n   */\n  tryActions(actions, str) {\n    // todo: use for.. of after https://github.com/facebook/react-native/issues/4676\n    for (let i = 0; i < actions.length; i++) {\n      let val = actions[i].call(this, str);\n      if (val !== null) {\n        return val;\n      }\n    }\n    return null;\n  }\n\n  tryCalcOperation(str) {\n    let opInfo = operation.isOperation(str);\n    if (!opInfo) {\n      return null;\n    }\n    this.isOperation = true;\n    // todo: use for.. of after https://github.com/facebook/react-native/issues/4676\n    const operands = ['v1', 'v2'];\n    for (let i = 0; i < operands.length; i++) {\n      const operand = operands[i];\n      const operandValue = this.calcOperandValue(opInfo[operand]);\n      if (operandValue !== null) {\n        opInfo[operand] = operandValue;\n      } else {\n        // if we cant calculate operand - it is not operation, see #3\n        return null;\n      }\n    }\n    return operation.exec(opInfo);\n  }\n\n  calcOperandValue(str) {\n    let actions = [\n      this.tryCalcVar,\n      this.tryCalcPercent,\n      this.tryCalcRem,\n      this.tryCalcFloat,\n    ];\n    return this.tryActions(actions, str);\n  }\n\n  tryCalcVar(str) {\n    if (vars.isVar(str)) {\n      let val = vars.calc(str, this.varsArr);\n      if (this.stack.indexOf(str) >= 0) {\n        throw new Error('Cyclic reference: ' + this.stack.concat([str]).join(' -> '));\n      }\n      const options = {\n        stack: this.stack.concat([str]),\n        isOperation: this.isOperation,\n      };\n      // recursive call because var can link to another var or percent/rem\n      return new Value(val, str, this.varsArr, options).calc();\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Tries calc percent\n   */\n  tryCalcPercent(str) {\n    if (percent.isPercent(str)) {\n      return percent.calc(str, this.prop);\n    }\n    return null;\n  }\n\n  /**\n   * Tries calc rem\n   */\n  tryCalcRem(str) {\n    if (rem.isRem(str)) {\n      let remValue = vars.get('$rem', this.varsArr);\n      return rem.calc(str, remValue);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Tries calc float value from string\n   */\n  tryCalcFloat(str) {\n    let val = parseFloat(str);\n    return !isNaN(val) ? val : null;\n  }\n\n  /**\n   * Is it final calculation (not recursion)\n   */\n  isFinal() {\n    return !this.stack.length;\n  }\n\n  /**\n   * Just proxies value when no processing needed\n   */\n  proxyValue() {\n    this.outValue = this.value;\n  }\n\n  applyScale() {\n    // do not apply scale to variables, only for final numbers\n    // otherwise scale will be applied several times\n    if (vars.isVar(this.prop)) {\n      return;\n    }\n    let scaleFactor = vars.get('$scale', this.varsArr) || 1;\n    if (scaleFactor === 1) {\n      return;\n    }\n    if (scale.isScalable(this.outValue, this.prop)) {\n      this.outValue = scale.calc(this.outValue, scaleFactor);\n    }\n  }\n}\n"]}